# 4 * 4のマスがあるパネルがあり、そこに白と黒が混在している。このとき黒のパネルをすべてひっくり返して、白だけにするときの最小回数を求める。
# 一つのマスを選んだ場合その行と列すべてをひっくり返す。
# 初期状態はマス目を選択する回数が最大になるようにする

# 上記から、すべて白の状態から選択するマス目が最大になるようにひっくり返して初期状態にすればよい
# 黒を1白を0として、16ビットの数値として考える

# 反転するマスクを設定 マスクとはフィルターみたいなもの
mask = Array.new(16)
4.times{|row|
    4.times{|col|
        mask[row * 4 + col] = 
            (0b1111 << (row * 4)) | (0b1000100010001 << col)  # row = 0, col = 0で考えると、0b1000100011111となる。パネルを一つ選ぶと、それを含めて行と列をすべてひっくり返すので、その条件を一枚ずつ書いていく。|はビット和
    }
}

max = 0
steps = Array.new(1 << 16, -1) # 1 << 16 は2進数の1を16ビット左にシフトするので、2＊＊16になる。こう定義するのは全状態を調べたときにすべてのパネルはすべて違うので(16ビットの数列も違う)その全通りが2**16
# すべて白からスタート
steps[0] = 0
# 調査対象の配列, 現時点でのパネルの状態
scanner = [0]
while scanner.size > 0 do
    check = scanner.shift       # checkには今の全パネルの状態
    next_steps = steps[check] + 1 # steps  keyはパネルの状態 value それになるまでのstep数、+ 1は前の状態から1ステップが増えたということ
    16.times{|i|
        n = check ^ mask[i]  # パネルを全数探索する。任意のパネルを選んだ時の状態をmaskのフィルターを使って排他的論理和をとる。その値(ひっくり返したあとの状態)をnに入れる
        # nの状態（ひっくり返した後の状態）が初期値のまま（そのパネルの状態になったことがない）だったら
        if steps[n] == -1 then  # nには10進数の値が入っている。数値として等しいので特別指定しない限り10進数になる。ひっくり返した後の状態が10進数表記になっている。
            steps[n] = next_steps
            scanner.push(n)  # つぎはnの状態から考えるから。
            max = next_steps if max < next_steps
        end
    }
end

puts max
puts steps.index(max).to_s(2)  # maxのstep数をvalueにもつindexを2進数で返す
p steps.select{|i| i == -1} # stepsの配列のうち未調査の場所を選んで返す     これが空になるときはすべての状態から白の状態戻すことができるということ