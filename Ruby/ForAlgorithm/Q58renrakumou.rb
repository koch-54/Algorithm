# 先生から生徒に電話してそこから生徒全員に連絡が最短で行きわたるようにする連絡網を考えたときその時間を求める。また、最短時間の連絡網のうち先生が電話する回数を最も少なくするときの回数も求める。
# 電話の時間を1分、一人の人は一人ずつしか電話できず、最後の生徒は先生に確認の電話をしなければならない。

# 各状態で区別する
# a: 誰からも連絡を受けてない状態 b: 先生から連絡を受けているか、先生に連絡したかの状態 c: 連絡を受けたが誰にも連絡していない状態
# ------- 状態の遷移 --------
# aの状態からbになる: 先生から連絡があった
# aの状態からcになる: 生徒から連絡があった
# bの状態からcになる: 生徒から連絡があった 
# cの状態からbになる: 先生に連絡をするか、ほかの生徒に連絡するか
# ---------------------------
# n人が全員bの状態になったら終了で最初はみんなaの状態

n = 14
# 初期状態の人数をセット(a, b, c, 先生が電話した回数)
status = [[n, 0, 0, 0]] # [[a, b, c, teacher]]
step = 0

while status.select{|s| s[1] == n}.size == 0 do
    next_status = []
    status.each{|s|
        (s[1] + 1).times{|b|
            # 連絡が不要なbの状態の人が連絡するとき        
            (s[2] + 1).times{|c|
               if s[2] > 0 then     # 発信ができるcの状態の人がいるとき
                # 受け取ったひとが先生に連絡するとき
                if s[0]-b-c+1 >= 0 then        # a(未受信)からb, c(受け取って状態が変わったひと)をひいて、受け取る先生分を+1する
                    next_status << [s[0]-b-c+1, s[1]+c, s[2]+b-1, s[3]+1]
                end
               end
               # 先生なし
               if s[0]-b-c >= 0 then
                    next_status << [s[0]-b-c, s[1]+c, s[2]+b, s[3]]
               end
               # 先生から生徒あり
               if s[0]-b-c-1 >= 0 then
                next_status << [s[0]-b-c-1, s[1]+c+1, s[2]+b, s[3]+1]
               end               
            }
        }
    }
    status = (next_status - status).uniq
    step += 1
end

puts step
p status.select{|s| s[1] == n}.min{|a, b| a[3] <=> b[3]}