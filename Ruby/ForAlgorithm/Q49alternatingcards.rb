# 2n枚のカードが円形に並んでいて、n枚の白いカードとn枚の黒いカードがそれぞれ色ごとに連続して並んでいる。
# このとき任意の連続する3枚のカードをひっくり返して色を変えていくとき、黒と白が交互になるための最小回数を求める
# n = 8の時を考える

N = 8           # 各色の数
start = (1 << N) - 1        # 開始状態(0がN個、1がN個) -1をしているのは8ビット左にシフトしてるので"100000000"になるところを"11111111"にしている
mask = (1 << N * 2) - 1     # ビットマスク      これも "10000000000000000" を "1111111111111111" にしている

# 白と黒の位置によってゴールが2種類になるので2つ設定する
goal1 = 0
N.times{|i| goal1 = (goal1 << 2) + 1}       # goal1は "1010101010101010"
# p goal1.to_s(2)
goal2 = mask - goal1            # goal2は "0101010101010101"

count = N * 2
(1 << N*2).times{|i|        # 交換する連続する3つの先頭。2つ以上選ばれる場合もある。このときは2回以上の回数操作したということ
    turn = i ^ (i << 1) ^ (i << 2)      
    turn = (turn ^ (turn >> (N * 2))) & mask        # 円形に並んでいるから 仮に"111000"となったときに "110001"と最初に戻す必要がある

    if (start ^ turn == goal1) || (start ^ turn == goal2) then
        count = [count, i.to_s(2).count('1')].min
    end
}

puts count